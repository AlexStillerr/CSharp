{
  "quizTitle": "C# Arrays",
  "questions": [
    {
      "question": "Wie wird in C# ein Array korrekt deklariert und initialisiert?",
      "answers": [
        {"text": "int[] zahlen = new int[5];", "isCorrect": true},
        {"text": "int zahlen = [1, 2, 3];", "isCorrect": false},
        {"text": "int[] zahlen = {1, 2, 3};", "isCorrect": true},
        {"text": "array<int> zahlen = new array<int>(3);", "isCorrect": false},
        {"text": "int zahlen = new int[]{1, 2, 3};", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Aussagen über die Größe eines Arrays in C# sind korrekt?",
      "answers": [
        {"text": "Die Größe eines Arrays ist nach der Erstellung unveränderlich.", "isCorrect": true},
        {"text": "Man kann mit Array.Resize() ein neues Array mit anderer Größe erzeugen.", "isCorrect": true},
        {"text": "Ein Array wächst automatisch, wenn man ein neues Element hinzufügt.", "isCorrect": false},
        {"text": "Mit List<T> kann man dynamisch wachsende Sammlungen statt Arrays nutzen.", "isCorrect": true},
        {"text": "array.Length kann verändert werden, um das Array zu kürzen.", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Aussagen über den Zugriff auf Array-Elemente sind korrekt?",
      "answers": [
        {"text": "Das erste Element hat den Index 1.", "isCorrect": false},
        {"text": "Auf das zweite Element greift man mit array[1] zu.", "isCorrect": true},
        {"text": "Ein IndexOutOfRangeException tritt auf, wenn man auf einen ungültigen Index zugreift.", "isCorrect": true},
        {"text": "Man kann mit einer foreach-Schleife über alle Elemente iterieren.", "isCorrect": true},
        {"text": "array.Last() ist eine eingebaute Eigenschaft des Arrays.", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Aussagen zu mehrdimensionalen Arrays in C# sind korrekt?",
      "answers": [
        {"text": "Ein zweidimensionales Array kann mit int[,] matrix = new int[3,3]; erstellt werden.", "isCorrect": true},
        {"text": "Mehrdimensionale Arrays können nur rechteckig, nicht gezackt sein.", "isCorrect": true},
        {"text": "Ein „jagged array“ ist ein Array von Arrays.", "isCorrect": true},
        {"text": "int[][] matrix = new int[3][3]; ist die richtige Syntax für ein zweidimensionales Array.", "isCorrect": false},
        {"text": "Man greift auf ein Element mit matrix[i,j] zu.", "isCorrect": true}
      ]
    },
    {
      "question": "Welche Methoden oder Eigenschaften kann man auf Arrays in C# verwenden?",
      "answers": [
        {"text": "array.Length gibt die Anzahl der Elemente zurück.", "isCorrect": true},
        {"text": "array.Sort() sortiert das Array direkt.", "isCorrect": false},
        {"text": "array.Reverse() kehrt die Reihenfolge um.", "isCorrect": false},
        {"text": "Array.IndexOf(array, value) sucht ein Element.", "isCorrect": true},
        {"text": "array.Append(value) fügt ein Element dauerhaft hinzu.", "isCorrect": false}
      ]
    }
  ]
}
{
  "quizTitle": "Reinforcement Learning – Fortgeschritten",
  "questions": [
    {
      "question": "Was beschreibt die Bellman-Gleichung im Kontext des Reinforcement Learnings?",
      "answers": [
        {"text": "Sie stellt eine rekursive Beziehung zwischen dem Wert eines Zustands und dem erwarteten zukünftigen Belohnungswert her.", "isCorrect": true},
        {"text": "Sie wird nur in modellbasierten RL-Methoden verwendet.", "isCorrect": false},
        {"text": "Sie dient der Berechnung von Gradienten in neuronalen Netzen.", "isCorrect": false},
        {"text": "Sie kann verwendet werden, um optimale Wertfunktionen zu approximieren.", "isCorrect": true},
        {"text": "Sie beschreibt ausschließlich die Belohnungsfunktion.", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Aussagen über den Unterschied zwischen Policy-Based und Value-Based Methoden sind korrekt?",
      "answers": [
        {"text": "Policy-Based Methoden lernen direkt eine Wahrscheinlichkeitsverteilung über Aktionen.", "isCorrect": true},
        {"text": "Value-Based Methoden approximieren den erwarteten Return für jeden Zustand oder jede Aktion.", "isCorrect": true},
        {"text": "Policy-Based Methoden benötigen zwingend ein Modell der Umgebung.", "isCorrect": false},
        {"text": "Value-Based Methoden sind immer deterministisch.", "isCorrect": false},
        {"text": "Actor-Critic kombiniert beide Ansätze.", "isCorrect": true}
      ]
    },
    {
      "question": "Was ist das Ziel des Policy-Gradient-Verfahrens?",
      "answers": [
        {"text": "Maximierung des erwarteten kumulierten Rewards durch direktes Anpassen der Policy-Parameter.", "isCorrect": true},
        {"text": "Minimierung des temporalen Unterschieds zwischen aufeinanderfolgenden Zuständen.", "isCorrect": false},
        {"text": "Erlernen eines Wertschätzers für jede Aktion.", "isCorrect": false},
        {"text": "Optimierung der Policy durch Gradientenaufstieg in Richtung besserer Aktionen.", "isCorrect": true},
        {"text": "Training der Policy über supervised learning mit gelabelten Beispielen.", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Aussagen über den Actor-Critic-Ansatz sind korrekt?",
      "answers": [
        {"text": "Der Actor aktualisiert die Policy, während der Critic den Wert der Aktionen schätzt.", "isCorrect": true},
        {"text": "Der Critic verwendet typischerweise eine Wertfunktion wie V(s) oder Q(s,a).", "isCorrect": true},
        {"text": "Actor-Critic ist eine reine Value-Based Methode.", "isCorrect": false},
        {"text": "Der Critic reduziert die Varianz der Gradientenabschätzung.", "isCorrect": true},
        {"text": "Der Actor verwendet keine Policy-Funktion.", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Methoden gehören zu den gängigen Explorationstechniken im RL?",
      "answers": [
        {"text": "ε-greedy", "isCorrect": true},
        {"text": "Softmax Action Selection", "isCorrect": true},
        {"text": "Dropout Regularization", "isCorrect": false},
        {"text": "Upper Confidence Bound (UCB)", "isCorrect": true},
        {"text": "Policy Distillation", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Vorteile bietet der Einsatz von Experience Replay in Deep Q-Networks (DQN)?",
      "answers": [
        {"text": "Er reduziert die Korrelation zwischen aufeinanderfolgenden Trainingsdaten.", "isCorrect": true},
        {"text": "Er ermöglicht effizientere Nutzung vergangener Erfahrungen.", "isCorrect": true},
        {"text": "Er beschleunigt die Berechnung des Bellman-Updates.", "isCorrect": false},
        {"text": "Er sorgt für stabileres Lernen durch zufälliges Sampling von Erfahrungen.", "isCorrect": true},
        {"text": "Er eliminiert das Problem des Overfittings vollständig.", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Verbesserungen wurden im Double DQN gegenüber dem klassischen DQN eingeführt?",
      "answers": [
        {"text": "Trennung der Aktionsauswahl und -bewertung, um Überschätzungsfehler zu reduzieren.", "isCorrect": true},
        {"text": "Verwendung zweier separater neuronaler Netze für Policy und Reward.", "isCorrect": false},
        {"text": "Reduzierung der Lernrate, um Stabilität zu erhöhen.", "isCorrect": false},
        {"text": "Verwendung eines zweiten Q-Netzes zur stabileren Schätzung der Zielwerte.", "isCorrect": true},
        {"text": "Einführung von Prioritized Experience Replay.", "isCorrect": false}
      ]
    },
    {
      "question": "Was beschreibt der Discount-Faktor (γ) im RL?",
      "answers": [
        {"text": "Er bestimmt, wie stark zukünftige Belohnungen gewichtet werden.", "isCorrect": true},
        {"text": "Ein γ-Wert von 0 führt dazu, dass nur unmittelbare Belohnungen berücksichtigt werden.", "isCorrect": true},
        {"text": "Ein γ-Wert von 1 führt zu einer vollständigen Missachtung zukünftiger Belohnungen.", "isCorrect": false},
        {"text": "Hohe γ-Werte fördern langfristig orientiertes Verhalten.", "isCorrect": true},
        {"text": "γ beeinflusst ausschließlich die Lernrate des Agenten.", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Aussagen treffen auf den Begriff 'Advantage Function' zu?",
      "answers": [
        {"text": "Sie beschreibt, wie viel besser eine Aktion im Vergleich zum Durchschnitt ist.", "isCorrect": true},
        {"text": "Sie wird häufig in Actor-Critic-Methoden zur Varianzreduktion eingesetzt.", "isCorrect": true},
        {"text": "Sie wird definiert als A(s,a) = Q(s,a) - V(s).", "isCorrect": true},
        {"text": "Sie ersetzt die Reward-Funktion im Training vollständig.", "isCorrect": false},
        {"text": "Sie ist nur in modellbasierten RL-Methoden relevant.", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Optimierungsstrategien werden häufig in Deep RL verwendet?",
      "answers": [
        {"text": "Adam Optimizer für neuronale Netzparameter.", "isCorrect": true},
        {"text": "Trust Region Policy Optimization (TRPO).", "isCorrect": true},
        {"text": "Stochastic Gradient Descent (SGD).", "isCorrect": true},
        {"text": "Dynamic Time Warping (DTW).", "isCorrect": false},
        {"text": "Genetic Algorithms zur Wertfunktionsschätzung.", "isCorrect": false}
      ]
    }
  ]
}
{
  "quizTitle": "C# – Windows Forms (WinForms)",
  "questions": [
    {
      "question": "Welche Klasse stellt das Hauptfenster einer WinForms-Anwendung dar?",
      "answers": [
        {"text": "Form", "isCorrect": true},
        {"text": "Window", "isCorrect": false},
        {"text": "MainWindow", "isCorrect": false},
        {"text": "UserControl", "isCorrect": false},
        {"text": "ApplicationContext", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Methode startet typischerweise die Ausführung einer WinForms-Anwendung?",
      "answers": [
        {"text": "Application.Run()", "isCorrect": true},
        {"text": "Form.Show()", "isCorrect": false},
        {"text": "Application.Start()", "isCorrect": false},
        {"text": "Program.Main()", "isCorrect": true},
        {"text": "Window.Run()", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Eigenschaften einer Form beeinflussen ihr Erscheinungsbild zur Laufzeit?",
      "answers": [
        {"text": "Text", "isCorrect": true},
        {"text": "BackColor", "isCorrect": true},
        {"text": "Dock", "isCorrect": false},
        {"text": "StartPosition", "isCorrect": true},
        {"text": "FontStyle", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Aussage zu Ereignissen (Events) in WinForms ist korrekt?",
      "answers": [
        {"text": "Ereignisse werden durch Delegates repräsentiert.", "isCorrect": true},
        {"text": "Ein Event-Handler muss die Signatur eines EventDelegate-Typs haben.", "isCorrect": true},
        {"text": "Ein Event kann nur einmal abonniert werden.", "isCorrect": false},
        {"text": "Mehrere Methoden können auf dasselbe Event reagieren.", "isCorrect": true},
        {"text": "Events werden ausschließlich durch Timer ausgelöst.", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Methoden sind typisch für das Zeichnen von benutzerdefinierten Oberflächen in WinForms?",
      "answers": [
        {"text": "OnPaint()", "isCorrect": true},
        {"text": "CreateGraphics()", "isCorrect": true},
        {"text": "PaintEventArgs.Graphics", "isCorrect": true},
        {"text": "RenderUI()", "isCorrect": false},
        {"text": "OnRender()", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Steuerelemente werden typischerweise für Benutzereingaben verwendet?",
      "answers": [
        {"text": "TextBox", "isCorrect": true},
        {"text": "Button", "isCorrect": false},
        {"text": "ComboBox", "isCorrect": true},
        {"text": "CheckBox", "isCorrect": true},
        {"text": "Label", "isCorrect": false}
      ]
    },
    {
      "question": "Wie kann man einen Hintergrundprozess ausführen, ohne die UI zu blockieren?",
      "answers": [
        {"text": "Verwendung eines BackgroundWorker.", "isCorrect": true},
        {"text": "Verwendung von async/await mit Task.Run().", "isCorrect": true},
        {"text": "Start eines Threads mit Thread.Start().", "isCorrect": true},
        {"text": "Verwendung von Thread.Sleep() im UI-Thread.", "isCorrect": false},
        {"text": "Blockieren der Application.Run()-Schleife.", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Eigenschaft eines Steuerelements bestimmt seine relative Position innerhalb eines Containers?",
      "answers": [
        {"text": "Dock", "isCorrect": true},
        {"text": "Anchor", "isCorrect": true},
        {"text": "Margin", "isCorrect": true},
        {"text": "TabIndex", "isCorrect": false},
        {"text": "ZIndex", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Aussage über MDI (Multiple Document Interface) in WinForms ist korrekt?",
      "answers": [
        {"text": "MDI ermöglicht es, mehrere untergeordnete Fenster in einem Hauptfenster zu öffnen.", "isCorrect": true},
        {"text": "Eine MDI-Elternform wird durch Setzen von IsMdiContainer = true erstellt.", "isCorrect": true},
        {"text": "Child-Forms müssen dieselbe Klasse wie das Hauptformular sein.", "isCorrect": false},
        {"text": "MDI wird über TabControl implementiert.", "isCorrect": false},
        {"text": "Ein MDI-Formular kann keine Menüs enthalten.", "isCorrect": false}
      ]
    },
    {
      "question": "Wie können Daten zwischen verschiedenen Formularen in einer WinForms-Anwendung ausgetauscht werden?",
      "answers": [
        {"text": "Durch Übergabe von Referenzen beim Erstellen des neuen Formulars.", "isCorrect": true},
        {"text": "Über öffentliche Eigenschaften oder Methoden der Form-Klasse.", "isCorrect": true},
        {"text": "Durch Verwendung von globalen statischen Variablen.", "isCorrect": true},
        {"text": "Durch direkten Zugriff auf Controls eines geschlossenen Formulars.", "isCorrect": false},
        {"text": "Über Windows Registry-Events.", "isCorrect": false}
      ]
    }
  ]
}
{
  "quizTitle": "C# – Threads und Nebenläufigkeit",
  "questions": [
    {
      "question": "Welche Klasse wird in C# für die Arbeit mit Threads direkt verwendet?",
      "answers": [
        {"text": "System.Threading.Thread", "isCorrect": true},
        {"text": "System.Threading.Tasks.Task", "isCorrect": false},
        {"text": "System.Threading.Timer", "isCorrect": false},
        {"text": "ThreadPool", "isCorrect": false},
        {"text": "System.Threading.Process", "isCorrect": false}
      ]
    },
    {
      "question": "Wie wird ein neuer Thread in C# gestartet?",
      "answers": [
        {"text": "Thread t = new Thread(MethodName); t.Start();", "isCorrect": true},
        {"text": "Thread.Start(MethodName);", "isCorrect": false},
        {"text": "Task.Run(MethodName);", "isCorrect": false},
        {"text": "new Thread(MethodName).Run();", "isCorrect": false},
        {"text": "new Thread(MethodName).Start();", "isCorrect": true}
      ]
    },
    {
      "question": "Welche Methoden gehören zur Thread-Klasse?",
      "answers": [
        {"text": "Start()", "isCorrect": true},
        {"text": "Join()", "isCorrect": true},
        {"text": "Abort()", "isCorrect": true},
        {"text": "Execute()", "isCorrect": false},
        {"text": "WaitAll()", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Aussage über Thread-Synchronisation ist korrekt?",
      "answers": [
        {"text": "lock-Statements verhindern gleichzeitigen Zugriff mehrerer Threads auf kritische Abschnitte.", "isCorrect": true},
        {"text": "Monitor.Enter() und Monitor.Exit() sind funktional äquivalent zu lock.", "isCorrect": true},
        {"text": "Mutex kann auch zwischen Prozessen verwendet werden.", "isCorrect": true},
        {"text": "lock blockiert niemals Threads.", "isCorrect": false},
        {"text": "SemaphoreSlim kann verwendet werden, um mehrere gleichzeitige Zugriffe zuzulassen.", "isCorrect": true}
      ]
    },
    {
      "question": "Welche Aussage über den ThreadPool ist korrekt?",
      "answers": [
        {"text": "Er verwaltet eine begrenzte Anzahl wiederverwendbarer Threads.", "isCorrect": true},
        {"text": "Threads aus dem ThreadPool können direkt gestoppt werden.", "isCorrect": false},
        {"text": "ThreadPool-Threads beenden sich automatisch nach der Arbeit.", "isCorrect": true},
        {"text": "ThreadPool ist ausschließlich für UI-Operationen gedacht.", "isCorrect": false},
        {"text": "QueueUserWorkItem() kann verwendet werden, um eine Aufgabe in den Pool zu legen.", "isCorrect": true}
      ]
    },
    {
      "question": "Welche Risiken bestehen bei unkoordinierter Thread-Nutzung?",
      "answers": [
        {"text": "Race Conditions", "isCorrect": true},
        {"text": "Deadlocks", "isCorrect": true},
        {"text": "Thread Starvation", "isCorrect": true},
        {"text": "Static Overflow", "isCorrect": false},
        {"text": "Stack Leakage", "isCorrect": false}
      ]
    },
    {
      "question": "Was bewirkt die Methode Thread.Join()?",
      "answers": [
        {"text": "Der aktuelle Thread wartet, bis der aufgerufene Thread beendet ist.", "isCorrect": true},
        {"text": "Beide Threads werden synchronisiert und laufen parallel weiter.", "isCorrect": false},
        {"text": "Der aufgerufene Thread wird sofort beendet.", "isCorrect": false},
        {"text": "Der aktuelle Thread wird in den ThreadPool verschoben.", "isCorrect": false},
        {"text": "Join() blockiert, bis der Thread abgeschlossen ist.", "isCorrect": true}
      ]
    },
    {
      "question": "Welche Unterschiede bestehen zwischen Thread und Task in C#?",
      "answers": [
        {"text": "Tasks sind höherstufige Abstraktionen für asynchrone Operationen.", "isCorrect": true},
        {"text": "Threads müssen manuell gestartet und verwaltet werden.", "isCorrect": true},
        {"text": "Tasks können einfacher kombiniert und fortgesetzt werden.", "isCorrect": true},
        {"text": "Threads sind Teil von async/await.", "isCorrect": false},
        {"text": "Tasks ersetzen vollständig alle Threads im .NET Framework.", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Synchronisationsmechanismen gibt es in .NET?",
      "answers": [
        {"text": "lock / Monitor", "isCorrect": true},
        {"text": "Mutex", "isCorrect": true},
        {"text": "Semaphore / SemaphoreSlim", "isCorrect": true},
        {"text": "Barrier", "isCorrect": true},
        {"text": "Thread.StopSignal", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Best Practices gelten für Multithreading in C#?",
      "answers": [
        {"text": "Vermeide gemeinsam genutzte mutable Zustände.", "isCorrect": true},
        {"text": "Nutze Thread.Sleep() zum Synchronisieren.", "isCorrect": false},
        {"text": "Bevorzuge Tasks und async/await für asynchrone Logik.", "isCorrect": true},
        {"text": "Führe UI-Updates immer aus einem Worker-Thread aus.", "isCorrect": false},
        {"text": "Verwende Concurrent-Klassen wie ConcurrentQueue oder ConcurrentDictionary.", "isCorrect": true}
      ]
    }
  ]
}
{
  "quizTitle": "C# – Tasks und async/await",
  "questions": [
    {
      "question": "Was ist der Hauptzweck des Task-basierten asynchronen Musters (TAP) in C#?",
      "answers": [
        {"text": "Es vereinfacht die asynchrone Programmierung durch Verwendung von Tasks.", "isCorrect": true},
        {"text": "Es ersetzt Threads vollständig.", "isCorrect": false},
        {"text": "Es ermöglicht nicht-blockierende Ausführung von Code.", "isCorrect": true},
        {"text": "Es benötigt explizite Thread-Verwaltung.", "isCorrect": false},
        {"text": "Es wird nur für UI-Operationen verwendet.", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Schlüsselwörter sind notwendig, um asynchrone Methoden in C# zu definieren?",
      "answers": [
        {"text": "async", "isCorrect": true},
        {"text": "await", "isCorrect": true},
        {"text": "yield", "isCorrect": false},
        {"text": "defer", "isCorrect": false},
        {"text": "task", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Methodenrückgabewerte sind für async-Methoden gültig?",
      "answers": [
        {"text": "Task", "isCorrect": true},
        {"text": "Task<T>", "isCorrect": true},
        {"text": "void", "isCorrect": true},
        {"text": "int", "isCorrect": false},
        {"text": "IEnumerable", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Aussage über das Schlüsselwort await ist korrekt?",
      "answers": [
        {"text": "Es pausiert die Ausführung der Methode, bis der Task abgeschlossen ist.", "isCorrect": true},
        {"text": "Es blockiert den Thread, auf dem es aufgerufen wird.", "isCorrect": false},
        {"text": "Es kann nur innerhalb von async-Methoden verwendet werden.", "isCorrect": true},
        {"text": "Es wird beim Aufruf von synchronen Methoden verwendet.", "isCorrect": false},
        {"text": "Es startet automatisch neue Threads.", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Vorteile bietet async/await gegenüber klassischen Threads?",
      "answers": [
        {"text": "Weniger Thread-Overhead und Ressourcenverbrauch.", "isCorrect": true},
        {"text": "Einfachere Fehlerbehandlung über Exceptions.", "isCorrect": true},
        {"text": "Automatische Rückkehr in den ursprünglichen Synchronisierungskontext (z. B. UI-Thread).", "isCorrect": true},
        {"text": "Automatische Parallelisierung von CPU-intensiven Aufgaben.", "isCorrect": false},
        {"text": "Direkte Hardwarebeschleunigung.", "isCorrect": false}
      ]
    },
    {
      "question": "Wie kann man verhindern, dass await zum UI-Thread zurückkehrt?",
      "answers": [
        {"text": "Mit ConfigureAwait(false).", "isCorrect": true},
        {"text": "Mit Thread.Detach().", "isCorrect": false},
        {"text": "Mit Task.RunDetached().", "isCorrect": false},
        {"text": "Mit await.ConfigureTask(false).", "isCorrect": false},
        {"text": "Mit Task.ConfigureAwait(false).", "isCorrect": true}
      ]
    },
    {
      "question": "Welche Methode wird verwendet, um mehrere Tasks gleichzeitig auszuführen und auf alle zu warten?",
      "answers": [
        {"text": "Task.WhenAll()", "isCorrect": true},
        {"text": "Task.WaitAll()", "isCorrect": true},
        {"text": "Task.WhenAny()", "isCorrect": false},
        {"text": "Task.Parallel()", "isCorrect": false},
        {"text": "TaskGroup.Join()", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Aussage zu Fehlern in async-Methoden ist korrekt?",
      "answers": [
        {"text": "Ausnahmen in Tasks werden als AggregateException gekapselt.", "isCorrect": true},
        {"text": "Mit await werden Exceptions direkt ausgelöst, nicht gekapselt.", "isCorrect": true},
        {"text": "Async-Methoden können keine Exceptions werfen.", "isCorrect": false},
        {"text": "Try/Catch funktioniert mit await wie bei synchronem Code.", "isCorrect": true},
        {"text": "Fehler werden automatisch im UI-Thread angezeigt.", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Methode startet eine asynchrone Operation ohne Rückgabewert?",
      "answers": [
        {"text": "Task.Run(() => { /* Code */ });", "isCorrect": true},
        {"text": "Thread.Start(() => { /* Code */ });", "isCorrect": false},
        {"text": "Task.Start(() => { /* Code */ });", "isCorrect": false},
        {"text": "async void MyMethod() { /* Code */ }", "isCorrect": true},
        {"text": "Task.RunAsync(() => { /* Code */ });", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Best Practices gelten für den Einsatz von async/await?",
      "answers": [
        {"text": "Vermeide async void außer bei Event-Handlern.", "isCorrect": true},
        {"text": "Nutze ConfigureAwait(false) in Bibliotheken.", "isCorrect": true},
        {"text": "Starte Tasks direkt im UI-Thread.", "isCorrect": false},
        {"text": "Kombiniere Task.WhenAll() für parallele async-Operationen.", "isCorrect": true},
        {"text": "Blockiere nie mit Task.Wait() oder .Result() im UI-Thread.", "isCorrect": true}
      ]
    }
  ]
}
{
  "quizTitle": "C# – Generics (Templates)",
  "questions": [
    {
      "question": "Was ist der Hauptzweck von Generics in C#?",
      "answers": [
        {"text": "Ermöglichen von typsicheren, wiederverwendbaren Klassen und Methoden.", "isCorrect": true},
        {"text": "Reduzierung der Notwendigkeit für Typumwandlungen (Casts).", "isCorrect": true},
        {"text": "Erhöhung der Performance durch Typbindung zur Laufzeit.", "isCorrect": false},
        {"text": "Verwendung von Reflection zur Typprüfung.", "isCorrect": false},
        {"text": "Vermeidung von Boxing und Unboxing bei Werttypen.", "isCorrect": true}
      ]
    },
    {
      "question": "Wie deklariert man eine generische Klasse in C#?",
      "answers": [
        {"text": "class MyClass<T> { }", "isCorrect": true},
        {"text": "template<class T> class MyClass { }", "isCorrect": false},
        {"text": "generic<T> class MyClass { }", "isCorrect": false},
        {"text": "class MyClass(type T) { }", "isCorrect": false},
        {"text": "class MyClass: T { }", "isCorrect": false}
      ]
    },
    {
      "question": "Wie definiert man eine Methode, die Generics verwendet?",
      "answers": [
        {"text": "void Print<T>(T value) { Console.WriteLine(value); }", "isCorrect": true},
        {"text": "template void Print<T>(T value)", "isCorrect": false},
        {"text": "static T Create<T>() where T : new()", "isCorrect": true},
        {"text": "T GetValue<T>(int id)", "isCorrect": true},
        {"text": "void Print(type T)", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Vorteile bieten Generics gegenüber dem Einsatz von object?",
      "answers": [
        {"text": "Typprüfung zur Kompilierzeit.", "isCorrect": true},
        {"text": "Bessere Performance durch Vermeidung von Boxing/Unboxing.", "isCorrect": true},
        {"text": "Einfachere Nutzung durch dynamische Typanpassung.", "isCorrect": false},
        {"text": "Sicherere API-Definitionen.", "isCorrect": true},
        {"text": "Automatische Thread-Synchronisierung.", "isCorrect": false}
      ]
    },
    {
      "question": "Welche generischen Einschränkungen (Constraints) sind in C# erlaubt?",
      "answers": [
        {"text": "where T : class", "isCorrect": true},
        {"text": "where T : struct", "isCorrect": true},
        {"text": "where T : new()", "isCorrect": true},
        {"text": "where T : static", "isCorrect": false},
        {"text": "where T : IDisposable", "isCorrect": true}
      ]
    },
    {
      "question": "Welche Aussage über Generics und Vererbung ist korrekt?",
      "answers": [
        {"text": "Generische Klassen können von anderen generischen Klassen erben.", "isCorrect": true},
        {"text": "Eine generische Klasse kann eine nicht-generische Basisklasse haben.", "isCorrect": true},
        {"text": "Generische Typen können in Interfaces verwendet werden.", "isCorrect": true},
        {"text": "Generische Typen können keine Interfaces implementieren.", "isCorrect": false},
        {"text": "Generische Basisklassen müssen denselben Typparameter haben.", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Klassen in .NET nutzen Generics intensiv?",
      "answers": [
        {"text": "List<T>", "isCorrect": true},
        {"text": "Dictionary<TKey, TValue>", "isCorrect": true},
        {"text": "ArrayList", "isCorrect": false},
        {"text": "Queue<T>", "isCorrect": true},
        {"text": "Hashtable", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Aussage über Covariance und Contravariance in C# ist korrekt?",
      "answers": [
        {"text": "Covariance erlaubt die Verwendung eines abgeleiteten Typs anstelle eines Basistyps (out).", "isCorrect": true},
        {"text": "Contravariance erlaubt die Verwendung eines Basistyps anstelle eines abgeleiteten Typs (in).", "isCorrect": true},
        {"text": "Variance gilt nur für Interfaces und Delegates.", "isCorrect": true},
        {"text": "Variance kann auf Klassen angewendet werden.", "isCorrect": false},
        {"text": "Variance funktioniert nur mit Werttypen.", "isCorrect": false}
      ]
    },
    {
      "question": "Welche Einschränkungen gelten für Typparameter mit new()-Constraint?",
      "answers": [
        {"text": "Der Typ muss einen parameterlosen öffentlichen Konstruktor besitzen.", "isCorrect": true},
        {"text": "Der Typ darf kein abstrakter Typ sein.", "isCorrect": true},
        {"text": "Der Typ kann eine Schnittstelle (Interface) sein.", "isCorrect": false},
        {"text": "Der Typ darf ein struct sein.", "isCorrect": false},
        {"text": "Der Typ kann generisch oder nicht-generisch sein.", "isCorrect": true}
      ]
    },
    {
      "question": "Welche Vorteile bieten generische Methoden in Interfaces?",
      "answers": [
        {"text": "Sie ermöglichen flexible Implementierungen mit unterschiedlichen Typen.", "isCorrect": true},
        {"text": "Sie erlauben typsichere Operationen ohne Code-Duplizierung.", "isCorrect": true},
        {"text": "Sie erzwingen die Verwendung von Reflection.", "isCorrect": false},
        {"text": "Sie sind nur in abstrakten Klassen erlaubt.", "isCorrect": false},
        {"text": "Sie können unterschiedliche Rückgabetypen pro Implementierung haben.", "isCorrect": true}
      ]
    }
  ]
}
